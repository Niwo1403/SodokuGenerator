package de.nicolai.sodoku_generator;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;


/**
 * Used to create sodokus.
 * @author Nicolai
 *
 */
public class SodokuGenerator {


	// Variables

	// Constants

	/**
	 * All possible elements for the permutation for lines.
	 */
	private static final String[] POSSIBLE_ELEMENTS = {"1", "2", "3", "4", "5", "6", "7", "8", "9"};
	/**
	 * Count of elements in POSSIBLE_ELEMENTS.
	 */
	private static final int LINE_ELEMENTS = 362_880; // 362_880 == 9!
	/**
	 * Max count of tries to find a new possible line in the sodoku.
	 */
	private static final int MAX_TRIES = 5_000;
	/**
	 * Count of lines in the sodoku.
	 */
	public static final int LINE_COUNT = 9;
	/**
	 * The length of the lines in the sodoku. (count of rows)
	 */
	public static final int LINE_LENGTH = 9;
	/**
	 * Step size for checking the squares.
	 */
	public static final int SQUARE_STEPS = 3;

	// Attributes

	/**
	 * Saves the all possible solutions.
	 */
	private final List<String> solutions = new ArrayList<>();
	/**
	 * Saves all possible combinations of different lines.
	 */
	private final String[][] lines = new String[LINE_ELEMENTS][LINE_COUNT];
	/**
	 * Keeps the position where to insert the next line in lines array.
	 */
	private int position;
	/**
	 * Saves if the lines are already generated.
	 */
	private boolean linesGenerated;


	// Constructor

	/**
	 * Initializing object without generating the lines.
	 */
	public SodokuGenerator() {
		this(false);
	}

	/**
	 * Initializing object. Pass true, to generate lines while initializing.
	 * @param generateLines if the lines should be generated by initializing
	 */
	public SodokuGenerator(final boolean generateLines) {
		super();
		if (generateLines)
			generateLines();
	}

	// Methods

	/**
	 * Generates a new sodoku.
	 */
	public void generateSodoku() {
		// Generate lines if they aren't now
		generateLines();
		// Generate sodokus
		final Sodoku sodoku = new Sodoku();

		// find solution
		while (!sodoku.isComplete()) { // new try for each iteration
			sodoku.reset();
			boolean reset = false;
			for (int i = 0; i < LINE_COUNT && !reset; i++) { // try to find 9 solutions
				reset = true; // ends the last loop if no solution is found fast enough
				for (int j = 0; j < (i * i + 1) * MAX_TRIES; j++)
					if (sodoku.addLine(lines[getRandomLineNumber()])) {
						// possible solution found
						reset = false; // block reset
						break;
					}
			}
		}


		// add sodoku to solutions
		solutions.add(sodoku.getStringRepresentation(solutions.size() + 1));
	}

	/**
	 * Create a random index in range of the lines.
	 * @return the random index of the line
	 */
	private int getRandomLineNumber() {
		return (int) (Math.random() * LINE_ELEMENTS);
	}

	/**
	 * Generates all possible lines.
	 */
	public final void generateLines() {
		if (!linesGenerated) {
			permute(POSSIBLE_ELEMENTS, 0, LINE_COUNT - 1);
			linesGenerated = true;
		}
	}


	/**
	 * Adds permutations to lines array.
	 * @param elements strings to build permutation of
	 * @param leftPos left point
	 * @param rightPos right point
	 */
    private void permute(final String[] elements, final int leftPos, final int rightPos) {
        if (leftPos == rightPos) {
        	// add new line
            System.arraycopy(elements, 0, lines[position], 0, LINE_COUNT);
            position++;
        } else {
        	// create copy for recursion
        	String[] elementsCopy = new String[LINE_COUNT];
            for (int i = leftPos; i <= rightPos; i++) {
            	System.arraycopy(elements, 0, elementsCopy, 0, LINE_COUNT);
            	// switch elements
            	final String tmp = elementsCopy[leftPos];
            	elementsCopy[leftPos] = elementsCopy[i];
            	elementsCopy[i] = tmp;
            	// recursive call
                permute(elementsCopy, leftPos + 1, rightPos);
            }
        }
    }

	/**
	 * Prints the created sodoku to the passed method.
	 * @param file Consumer object, which gets the content.
	 */
	public void print(final Consumer<String> file) {
		// Redirect to ArrayList
		solutions.forEach(file);
	}

	// Overrides

	/**
	 * Return a string representation of the sodokus.
	 * @return the sodoku solutions joined to a string
	 */
	@Override
	public String toString() {
		return String.join("", solutions);
	}

}
