package de.nicolai.sodoku_generator;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

import java.util.Random;


/**
 * Used to create sodokus.
 * @author Nicolai
 *
 */
public class SodokuGenerator {


	// Variables

	// Constants

	/**
	 * All possible elements for the permutation for lines.
	 */
	protected static final String[] POSSIBLE_ELEMENTS = {"1", "2", "3", "4", "5", "6", "7", "8", "9"};
	/**
	 * Count of elements in POSSIBLE_ELEMENTS.
	 */
	private static final int LINE_ELEMENTS = 362_880; // 362_880 == 9!
	/**
	 * Max count of tries to find a new possible line in the sodoku.
	 */
	private static final int MAX_TRIES = 5_000;
	/**
	 * Count of lines in the sodoku.
	 */
	public static final int LINE_COUNT = 9;
	/**
	 * The length of the lines in the sodoku. (count of rows)
	 */
	public static final int LINE_LENGTH = 9;
	/**
	 * Step size for checking the squares.
	 */
	public static final int SQUARE_STEPS = 3;

	// Attributes

	/**
	 * Saves the all possible solutions.
	 */
	private final List<String> solutions = new ArrayList<>();
	/**
	 * Saves all possible combinations of different lines.
	 */
	private static final String[][] LINES = new String[LINE_ELEMENTS][LINE_COUNT];
	/**
	 * Keeps the position where to insert the next line in lines array.
	 */
	private static int position;
	/**
	 * Used to generate random numbers.
	 */
	private final IndexGenerator iGenerator = new IndexGenerator(LINE_ELEMENTS);

	/**
	 * Generates all possible lines.
	 */
	static {
		permute(POSSIBLE_ELEMENTS, 0, LINE_COUNT - 1);
	}

	// Constructor

	/**
	 * Initializing object without generating the lines.
	 */
	public SodokuGenerator() {
		this(false);
	}

	/**
	 * Initializing object. Pass true, to generate lines while initializing.
	 * @param generateLines if the lines should be generated by initializing
	 */
	public SodokuGenerator(final boolean generateLines) {
		super();
	}

	// static Methods

	/**
	 * Adds permutations to lines array.
	 * @param elements strings to build permutation of
	 * @param leftPos left point
	 * @param rightPos right point
	 */
    private static void permute(final String[] elements, final int leftPos, final int rightPos) {
        if (leftPos == rightPos) {
        	// add new line
            System.arraycopy(elements, 0, LINES[position], 0, LINE_COUNT);
            position++;
        } else {
        	// create copy for recursion
        	String[] elementsCopy = new String[LINE_COUNT];
            for (int i = leftPos; i <= rightPos; i++) {
            	System.arraycopy(elements, 0, elementsCopy, 0, LINE_COUNT);
            	// switch elements
            	final String tmp = elementsCopy[leftPos];
            	elementsCopy[leftPos] = elementsCopy[i];
            	elementsCopy[i] = tmp;
            	// recursive call
                permute(elementsCopy, leftPos + 1, rightPos);
            }
        }
    }

	// Methods

	/**
	 * Generates a new sodoku and adds it to the solution.
	 */
	public void generateSodoku() {
		// add sodoku to solutions
		solutions.add(getSodoku().getStringRepresentation(solutions.size() + 1));
	}

	/**
	 * Generates a new sodoku.
	 * @return the generated sodoku
	 */
	public Sodoku getSodoku() {
		// Generate sodokus
		final Sodoku sodoku = new Sodoku();

		// find solution
		while (!sodoku.isComplete()) { // new try for each iteration
			sodoku.reset();
			boolean reset = false;
			for (int i = 0; i < LINE_COUNT - 1 && !reset; i++) { // try to find 7 solutions
				reset = true; // ends the last loop if no solution is found fast enough
				for (int j = 0; j < (i * i + 1) * MAX_TRIES; j++)
					if (sodoku.addLine(LINES[getRandomLineNumber()])) {
						// possible solution found
						reset = false; // block reset
						break;
					}
			}
			generateLastLine(sodoku);
		}
		return sodoku;
	}

	/**
	 * Adds the last line to a sodoku, if possible.
	 * @param sodoku sodoku to add the last line to
	 */
	private void generateLastLine(final Sodoku sodoku) {
		final String[] lastLine = new String[LINE_LENGTH];
		for (int i = 0; i < SodokuGenerator.LINE_LENGTH; i++)
			lastLine[i] = sodoku.getMissingElementsOfRow(i)[0];
		sodoku.addLine(lastLine);
	}

	/**
	 * Create a random index in range of the lines.
	 * @return the random index of the line
	 */
	private int getRandomLineNumber() {
		return iGenerator.getIndex();
	}

	/**
	 * Prints the created sodoku to the passed method.
	 * @param file Consumer object, which gets the content.
	 */
	public void print(final Consumer<String> file) {
		// Redirect to ArrayList
		solutions.forEach(file);
	}

	// Overrides

	/**
	 * Return a string representation of the sodokus.
	 * @return the sodoku solutions joined to a string
	 */
	@Override
	public String toString() {
		return String.join("", solutions);
	}

	// inner classes

	/**
	 * Used to generate random indexes for accessing the LINE array
	 * and get random lines.
	 * Creates 4 random numbers at a time,
	 * which associated lines are as different as possible.
	 * @author Nicolai
	 *
	 */
	private class IndexGenerator {
		/**
		 * The number of generated indexes for each random number.
		 */
		private static final int BUFFER_SIZE = 4;
		/**
		 * For creating random numbers.
		 */
		private final Random numberGenerator = new Random();
		/**
		 * A quarter of the array length, the indexes are for.
		 */
		private final int elementQuarter;
		/**
		 * Saves the 4 random numbers.
		 */
		private int[] intBuffer = new int[BUFFER_SIZE];
		/**
		 * Position of the index in the buffer, which should be returned next.
		 */
		private int bufferPos;

		// Methods

		/**
		 * Creates an IndexGenerator object matching an array of size arrSize.
		 * @param arrSize size of the array, the index is for
		 */
		public IndexGenerator(final int arrSize) {
			elementQuarter = arrSize / BUFFER_SIZE;
		}

		/**
		 * Returns a possible index for the LINE array.
		 * @return the line index
		 */
		public int getIndex() {
			if (bufferPos >= BUFFER_SIZE)
				generateNewNumbers();
			return intBuffer[bufferPos++];
		}

		/**
		 * Generates the next 4 indexes from a random number.
		 */
		private void generateNewNumbers() {
			final int randNum = numberGenerator.nextInt(LINE_ELEMENTS);
			bufferPos = 0;
			for (int i = 0; i < BUFFER_SIZE; i++)
				intBuffer[i] = (randNum + elementQuarter * i) % LINE_ELEMENTS;
		}
	}
}
