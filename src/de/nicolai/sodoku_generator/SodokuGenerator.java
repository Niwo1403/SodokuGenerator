package de.nicolai.sodoku_generator;

import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;


/**
 * Used to create sodokus.
 * @author Nicolai
 *
 */
public class SodokuGenerator {


	// Variables

	// Constants

	/**
	 * All possible elements for the permutation for lines.
	 */
	private static final String[] POSSIBLE_ELEMENTS = {"1", "2", "3", "4", "5", "6", "7", "8", "9"};
	/**
	 * Count of elements in POSSIBLE_ELEMENTS.
	 */
	private static final int LINE_ELEMENTS = 362_880; // 362_880 == 9!
	/**
	 * Max count of tries to find a new possible line in the sodoku.
	 */
	private static final int MAX_TRIES = 5_000;
	/**
	 * Count of lines in the sodoku.
	 */
	private static final int LINE_COUNT = 9;
	/**
	 * The length of the lines in the sodoku. (count of rows)
	 */
	private static final int LINE_LENGTH = 9;
	/**
	 * Step size for checking the squares.
	 */
	private static final int SQUARE_STEPS = 3;

	// Attributes

	/**
	 * Saves the all possible solutions.
	 */
	private final List<String> solutions = new ArrayList<>();
	/**
	 * Saves all possible combinations of different lines.
	 */
	private final String[][] lines = new String[LINE_ELEMENTS][LINE_COUNT];
	/**
	 * Keeps the position where to insert the next line in lines array.
	 */
	private int position;
	/**
	 * Saves if the lines are already generated.
	 */
	private boolean linesGenerated;


	// Constructor

	/**
	 * Initializing object without generating the lines.
	 */
	public SodokuGenerator() {
		this(false);
	}

	/**
	 * Initializing object. Pass true, to generate lines while initializing.
	 * @param generateLines if the lines should be generated by initializing
	 */
	public SodokuGenerator(final boolean generateLines) {
		super();
		if (generateLines)
			generateLines();
	}

	// Methods

	/**
	 * Generates a new sodoku.
	 */
	public void generateSodoku() {
		// Generate lines if they aren't now
		generateLines();
		// Generate sodokus
		final Sodoku sodoku = new Sodoku();

		// find solution
		while (!sodoku.isComplete()) { // new try for each iteration
			sodoku.reset();
			boolean reset = false;
			for (int i = 0; i < LINE_COUNT && !reset; i++) { // try to find 9 solutions
				reset = true; // ends the last loop if no solution is found fast enough
				for (int j = 0; j < (i * i + 1) * MAX_TRIES; j++)
					if (sodoku.addLine(lines[getRandomLineNumber()])) {
						// possible solution found
						reset = false; // block reset
						break;
					}
			}
		}


		// add sodoku to solutions
		solutions.add(sodoku.getStringRepresentation(solutions.size() + 1));
	}

	/**
	 * Create a random index in range of the lines.
	 * @return the random index of the line
	 */
	private int getRandomLineNumber() {
		return (int) (Math.random() * LINE_ELEMENTS);
	}

	/**
	 * Generates all possible lines.
	 */
	public final void generateLines() {
		if (!linesGenerated) {
			permute(POSSIBLE_ELEMENTS, 0, LINE_COUNT - 1);
			linesGenerated = true;
		}
	}


	/**
	 * Adds permutations to lines array.
	 * @param elements strings to build permutation of
	 * @param leftPos left point
	 * @param rightPos right point
	 */
    private void permute(final String[] elements, final int leftPos, final int rightPos) {
        if (leftPos == rightPos) {
        	// add new line
            System.arraycopy(elements, 0, lines[position], 0, LINE_COUNT);
            position++;
        } else {
        	// create copy for recursion
        	String[] elementsCopy = new String[LINE_COUNT];
            for (int i = leftPos; i <= rightPos; i++) {
            	System.arraycopy(elements, 0, elementsCopy, 0, LINE_COUNT);
            	// switch elements
            	final String tmp = elementsCopy[leftPos];
            	elementsCopy[leftPos] = elementsCopy[i];
            	elementsCopy[i] = tmp;
            	// recursive call
                permute(elementsCopy, leftPos + 1, rightPos);
            }
        }
    }

	/**
	 * Prints the created sodoku to the passed method.
	 * @param file Consumer object, which gets the content.
	 */
	public void print(final Consumer<String> file) {
		// Redirect to ArrayList
		solutions.forEach(file);
	}

	// Overrides

	/**
	 * Return a string representation of the sodokus.
	 * @return the sodoku solutions joined to a string
	 */
	@Override
	public String toString() {
		return String.join("", solutions);
	}


	//Classes

	/**
	 * Builds a sodoku.
	 * @author Nicolai
	 */
	private class Sodoku {

		// Variables

		/**
		 * saves the added numbers.
		 */
		private String[][] content = new String[LINE_COUNT][LINE_LENGTH];
		/**
		 * Count of the correct line.
		 */
		private int currentLine;


		// Constructor

		/**
		 * Default constructor.
		 */
		public Sodoku() {
			super();
		}

		// Methods

		/**
		 * Tests if the current lines are a possible solution.
		 * @return true if all current rows could be a possible solution
		 */
		private boolean test() {
			// lines couldn't be wrong
			// Check rows
			final String[] existingElements = new String[LINE_COUNT];
			for (int i = 0; i < LINE_COUNT; i++) {
				for (int j = 0; j <= currentLine; j++)
					if (include(existingElements, content[j][i]))
						return false;
					else
						existingElements[j] = content[j][i];
			}

			// Check squares
			for (int i = 0; i < currentLine; i += SQUARE_STEPS) // big lines
				for (int j = 0; j < LINE_LENGTH; j += SQUARE_STEPS) { // big rows
					int index = 0;
					for (int k = i; k < i + LINE_COUNT / SQUARE_STEPS; k++) // lines
						for (int l = j; l < j + LINE_LENGTH / SQUARE_STEPS; l++) // rows
							if (include(existingElements, content[k][l]))
								return false;
							else
								existingElements[index++] = content[k][l];

				}

			// nothing failed -> return true
			return true;
		}

		/**
		 * Checks if arr contains searchFor. Stops searching, if element is null.
		 * @param arr array to search in
		 * @param searchFor	string to search for
		 * @return true, if arr contains searchFor
		 */
		private boolean include(final String[] arr, final String searchFor) {
			for (final String elm:arr)
				if (elm != null && elm.equals(searchFor))
					return true;
			return false;
		}

		/**
		 * Try to add a line.
		 * @param line the line to add to the sodoku.
		 * @return if the line could be added.
		 */
		public boolean addLine(final String... line) {
			if (line.length != LINE_LENGTH) // check if the line length is correct
				return false;
			if (isComplete()) // if sodoku is complete
				return false;

			// add line to content
			System.arraycopy(line, 0, content[currentLine], 0, LINE_COUNT);

			// check if line could be added
			if (test()) {
				increaseLines();
				return true;
			} else
				return false;
		}

		/**
		 * Creates a text representation of the sodoku.
		 * @param number
		 * @return a sting representation of the sodoku,
		 * including the number in the headline
		 */
		public String getStringRepresentation(final int number) {
			if (isComplete())
				return "Sodoku number " + number + ":\n" + toString() + "\n";
			else
				return "";
		}

		/**
		 * Checks if the sodoku is complete.
		 * @return true if the sodoku got 9 correct lines
		 */
		public boolean isComplete() {
			return currentLine == LINE_COUNT;
		}

		/**
		 * Resets the sodoku, to an empty one. (like new initialized)
		 */
		public void reset() {
			setLine(0);
			content = new String[LINE_COUNT][LINE_LENGTH];
		}


		// Overrides

		@Override
		public String toString() {
			String ret = "";
			for (int i = 0; i < LINE_COUNT; i++)
				ret += String.join(", ", content[i]) + "\n";
			return ret;
		}

		// Getter, Setter

		/**
		 * Set the currentLine.
		 * @param newCurrentLine new value of the CurrentLine;
		 */
		public void setLine(final int newCurrentLine) {
			if (newCurrentLine >= 0 && newCurrentLine <= LINE_COUNT)
				// if LINE_COUNT equals newCurrentLine the sodoku is complete, so <= instead of <
				currentLine = newCurrentLine;
		}

		/**
		 * Increases the currentLine by one.
		 */
		public void increaseLines() {
			setLine(currentLine + 1);
		}

	}

}
